package org.vitrivr.cottontail.execution.operators.predicates

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.flow.flow

import org.vitrivr.cottontail.database.queries.predicates.knn.KnnPredicate
import org.vitrivr.cottontail.execution.TransactionContext
import org.vitrivr.cottontail.execution.operators.basics.Operator
import org.vitrivr.cottontail.math.knn.selection.ComparablePair
import org.vitrivr.cottontail.math.knn.selection.MinHeapSelection
import org.vitrivr.cottontail.math.knn.selection.MinSingleSelection
import org.vitrivr.cottontail.math.knn.selection.Selection
import org.vitrivr.cottontail.model.basics.ColumnDef
import org.vitrivr.cottontail.model.basics.Record
import org.vitrivr.cottontail.model.recordset.StandaloneRecord
import org.vitrivr.cottontail.model.values.DoubleValue
import org.vitrivr.cottontail.model.values.types.Value
import org.vitrivr.cottontail.model.values.types.VectorValue
import org.vitrivr.cottontail.utilities.math.KnnUtilities

/**
 * An [Operator.PipelineOperator] used during query execution. Performs a kNN lookup on the input
 * generated by the parent [Operator] using the given [KnnPredicate].
 *
 * Produces querySize * k [Record]s. Acts as pipeline breaker.
 *
 * @author Ralph Gasser
 * @version 1.2.0
 */
class KnnOperator(parent: Operator, val knn: KnnPredicate) : Operator.PipelineOperator(parent) {

    /** The columns produced by this [KnnOperator]. */
    override val columns: Array<ColumnDef<*>> = arrayOf(
        *this.parent.columns,
        KnnUtilities.distanceColumnDef(this.knn.column.name.entity())
    )

    /** [KnnOperator] does act as a pipeline breaker. */
    override val breaker: Boolean = true

    /**
     * Converts this [KnnOperator] to a [Flow] and returns it.
     *
     * @param context The [TransactionContext] used for execution
     * @return [Flow] representing this [KnnOperator]
     */
    override fun toFlow(context: TransactionContext): Flow<Record> {
        /* Obtain parent flow. */
        val parentFlow = this.parent.toFlow(context)

        /* Prepare data structures and logic for kNN. */
        val knnSet: List<Selection<ComparablePair<Record, DoubleValue>>> = if (this.knn.k == 1) {
            knn.query.map { MinSingleSelection() }
        } else {
            knn.query.map { MinHeapSelection(this.knn.k) }
        }
        val action: (Record) -> Unit = if (this.knn.weights != null) {
            {
                val value = it[this.knn.column]
                if (value is VectorValue<*>) {
                    this.knn.query.forEachIndexed { i, query ->
                        knnSet[i].offer(ComparablePair(it, this.knn.distance(query, value, this.knn.weights[i])))
                    }
                }
            }
        } else {
            {
                val value = it[this.knn.column]
                if (value is VectorValue<*>) {
                    this.knn.query.forEachIndexed { i, query ->
                        knnSet[i].offer(ComparablePair(it, this.knn.distance(query, value)))
                    }
                }
            }
        }

        /* Generate new flow. */
        return flow {
            parentFlow.collect { record ->
                action(record)
            }
            val values = ArrayList<Value?>(this@KnnOperator.columns.size + 1)
            for (knn in knnSet) {
                for (i in 0 until knn.size) {
                    values.clear()
                    knn[i].first.forEach { _, value -> values.add(value) }
                    values.add(DoubleValue(knn[i].second))
                    emit(StandaloneRecord(knn[i].first.tupleId, this@KnnOperator.columns, values.toTypedArray()))
                }
            }
        }
    }
}